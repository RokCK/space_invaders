<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - Retro Edition</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #00ff00;
            background: #000;
            box-shadow: 0 0 20px #00ff00;
        }
        
        #score {
            font-size: 24px;
            margin-bottom: 10px;
            color: #00ff00;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0000;
            text-shadow: 2px 2px 4px #000;
            display: none;
        }
        
        #paused {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ffff00;
            text-shadow: 2px 2px 4px #000;
            display: none;
        }
        
        #instructions {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }
        
        /* Level intro and victory overlays */
        #levelIntro, #victoryBanner, #introBanner {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #00ffff;
            text-align: center;
            padding: 24px 32px;
            background: rgba(0,0,0,0.75);
            border: 2px solid rgba(0,255,255,0.2);
            border-radius: 12px;
            display: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 450ms ease;
        }
        
        #levelIntro span, #victoryBanner span, #introBanner span { font-size: 18px; color: #fff; display: block; margin-top: 8px; }

        /* visible state for overlays (fade) */
        .overlay-visible {
            display: block !important;
            opacity: 1 !important;
            pointer-events: auto;
        }
        
        /* Intro banner */
        #introBanner {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #00ff99;
            text-align: center;
            padding: 20px 26px;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(0,255,153,0.2);
            border-radius: 10px;
            display: none;
            z-index: 1000;
        }
        #introBanner span { display:block; margin-top:8px; color:#fff; font-size:16px }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameOver">GAME OVER<br><span style="font-size: 24px;">Press R to Restart</span></div>
        <div id="paused">PAUSED<br><span style="font-size: 24px;">Press P to Resume</span></div>
    <div id="introBanner" class="overlay">Welcome to Space Invaders.<br><span>You work here is to save the World. Please destroy all the enemies.<br><strong>Press SPACE to continue</strong></span></div>
    <div id="levelIntro" class="overlay">Level 1<br><span>Press SPACE to start</span></div>
    <div id="victoryBanner" class="overlay">Congratulations! You saved the World!!!<br><span>Press R to Restart</span></div>
        <div id="instructions">
            Use ‚Üê ‚Üí arrows to move, SPACE to shoot, P to pause, R to restart<br>
            <span style="color: #ff0066;">üî∫ Triangles: Shoot twice as fast after 1st hit! Need 2 hits total</span><br>
            <span style="color: #ff6600;">üüß Squares: Shrink and shoot immediately when hit! Break on 2nd hit</span><br>
            <span style="color: #00ffff;">üíé Diamonds: Split into 2 smaller diamonds when hit! Small diamonds break in 1 hit</span><br>
            <span style="color: #ffff00;">‚ö™ Circles: Randomly disappear for moments! Need 2 hits</span><br>
            <span style="color: #9900ff;">‚≠ê Stars: Standard 2 hits</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const pausedElement = document.getElementById('paused');

        // Game state
        let gameRunning = true;
        let gamePaused = false;
    let levelIntroActive = false; // will show after intro
    let introActive = true; // show the welcome intro first
        let score = 0;
        let level = 1;
        let invaderDirection = 1;
        // Base speed (pixels per frame unit) and computed invader speed
        let baseInvaderSpeed = 0.5;
        let invaderSpeed = baseInvaderSpeed;

        // Returns multiplier based on level according to the requested mapping
        function getInvaderSpeedMultiplier(lvl) {
            // explicit mapping for levels 1..10
            const table = [1.0, 1.1, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0];
            if (lvl <= 0) return 1.0;
            if (lvl <= 10) return table[lvl - 1];
            // After level 10, increase by 0.1 per level (level20 => 3.0, etc.)
            return 2.0 + (lvl - 10) * 0.1;
        }
        let gameTime = 0;
        let lastDirectionChange = 0; // Prevent rapid direction changes
        // Timestamp (ms) until which newly spawned invaders are invulnerable to collisions
        let invadersInvulnerableUntil = 0;

        // Frame rate independent movement variables
        let lastTime = 0;
        const targetFPS = 60;
        const targetFrameTime = 1000 / targetFPS;

        // Player
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 60,
            width: 50,
            height: 30,
            speed: 5,
            color: '#00ff00'
        };

        // Arrays for game objects
        let bullets = [];
        let invaders = [];
        let invaderBullets = [];
        let particles = [];

        // Gameplay caps
        const MAX_INVADER_BULLETS = 3; // m√°ximo de proyectiles en pantalla disparados por los enemigos

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                // Only shoot on the initial keydown (avoid auto-repeat when holding the key)
                if (introActive) {
                    // Keep introActive true until fade finishes so the game update
                    // loop remains paused; then show level intro
                    fadeOut(document.getElementById('introBanner'), () => {
                        introActive = false;
                        showLevelIntro();
                    });
                } else if (levelIntroActive) {
                    // Start the level when Space is pressed on the level intro
                    // Keep levelIntroActive true until fade completes to avoid
                    // resuming update() while old invaders array still contains
                    // dead items and immediately increments the level again.
                    fadeOut(document.getElementById('levelIntro'), () => {
                        levelIntroActive = false;
                        // create invaders and start
                        createInvadersForLevel();
                    });
                } else {
                    if (!e.repeat && gameRunning && !gamePaused) shoot();
                }
            }
            if (e.code === 'KeyR') {
                restartGame();
            }
            if (e.code === 'KeyP') {
                togglePause();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Toggle pause function
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            if (gamePaused) {
                pausedElement.style.display = 'block';
            } else {
                pausedElement.style.display = 'none';
            }
        }

        // Invader types with different shapes and colors - REORDERED
        const invaderTypes = [
            { color: '#ff0066', shape: 'triangle', points: 20, canShoot: true },
            { color: '#ff6600', shape: 'square', points: 10, canShoot: false },
            { color: '#00ffff', shape: 'diamond', points: 10, canShoot: false },
            { color: '#ffff00', shape: 'circle', points: 3, canShoot: false },
            { color: '#9900ff', shape: 'star', points: 2, canShoot: false }
        ];

        // Create invaders
        function createInvaders() {
            invaders = [];
            const rows = 5;
            const cols = 10;
            const invaderWidth = 40;
            const invaderHeight = 30;
            const spacing = 60;
            const startX = (canvas.width - (cols * spacing)) / 2;
            const startY = 50;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const typeIndex = row % invaderTypes.length;
                    const invaderType = invaderTypes[typeIndex];
                    
                    invaders.push({
                        x: startX + col * spacing,
                        y: startY + row * spacing,
                        width: invaderWidth,
                        height: invaderHeight,
                        type: invaderType,
                        alive: true,
                        animFrame: 0,
                        hits: 0,
                        maxHits: 2,
                        shootSpeed: invaderType.shape === 'triangle' ? 1 : 0,
                        // Diamond-specific properties
                        isDiamondSplit: false,
                        splitDirection: 0,
                        originalX: startX + col * spacing, // Store original X position
                        originalY: startY + row * spacing, // Store original Y position
                        // Circle-specific properties
                        isVisible: true,
                        lastVisibilityToggle: 0,
                        invisibilityDuration: 0,
                        // Square-specific properties
                        hasShot: false, // Track if square has shot after being hit
                        originalSize: 15,
                        // Movement properties
                        isMainFormation: true // Track if this is part of main formation
                    });
                }
            }
            // Show level intro overlay and pause until player presses Space
            showLevelIntro();
        }

        function showLevelIntro() {
            // Victory condition when finishing level 50
            if (level > 50) {
                fadeIn(document.getElementById('victoryBanner'));
                gameRunning = false;
                return;
            }

            levelIntroActive = true;
            const el = document.getElementById('levelIntro');
            el.innerHTML = `Level ${level}<br><span>Press SPACE to start</span>`;
            fadeIn(el);
        }

        // helper: create invaders but separated so we can control timing with fades
        function createInvadersForLevel() {
                    // clear any existing bullets/particles from the previous level so
                    // they don't immediately collide with newly spawned invaders and
                    // cause an unintended instant level-up
                    bullets = [];
                    invaderBullets = [];
                    particles = [];
                    // initialize invaders array and positions
                    invaders = [];
                    // reset directional state/timers so formation starts consistently
                    invaderDirection = 1;
                    gameTime = 0;
                    lastDirectionChange = 0;
            const rows = 5;
            const cols = 10;
            const invaderWidth = 40;
            const invaderHeight = 30;
            const spacing = 60;
            const startX = (canvas.width - (cols * spacing)) / 2;
            const startY = 50;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const typeIndex = row % invaderTypes.length;
                    const invaderType = invaderTypes[typeIndex];
                    invaders.push({
                        x: startX + col * spacing,
                        y: startY + row * spacing,
                        width: invaderWidth,
                        height: invaderHeight,
                        type: invaderType,
                        alive: true,
                        animFrame: 0,
                        hits: 0,
                        maxHits: 2,
                        shootSpeed: invaderType.shape === 'triangle' ? 1 : 0,
                        isDiamondSplit: false,
                        splitDirection: 0,
                        originalX: startX + col * spacing,
                        originalY: startY + row * spacing,
                        isVisible: true,
                        lastVisibilityToggle: 0,
                        invisibilityDuration: 0,
                        hasShot: false,
                        originalSize: 15,
                        isMainFormation: true
                    });
                }
            }
            // start the level loop normally after creation
            // give new invaders a short invulnerability window so they won't
            // immediately get hit by any leftover bullets or visual remnants
            invadersInvulnerableUntil = Date.now() + 500; // 500 ms
        }

        // Fade helpers
        function fadeIn(el) {
            el.classList.add('overlay-visible');
        }

        function fadeOut(el, cb) {
            el.classList.remove('overlay-visible');
            // wait for transition duration then hide
            setTimeout(() => {
                el.style.display = 'none';
                if (cb) cb();
            }, 480);
        }

        // Create a split diamond
        function createSplitDiamond(originalDiamond, direction) {
                    // Make each split occupy exactly half the width of the original
                    const splitWidth = originalDiamond.width / 2;
                    const splitHeight = originalDiamond.height; // keep same height

                    // Position left split at original x, right split immediately after
                    const baseX = originalDiamond.x;
                    const newX = baseX + (direction === 1 ? splitWidth : 0);

                    return {
                        x: newX,
                        y: originalDiamond.y,
                        width: splitWidth,
                        height: splitHeight,
                        type: originalDiamond.type,
                        alive: true,
                        animFrame: originalDiamond.animFrame,
                        hits: 0,
                        maxHits: 1,
                        shootSpeed: 0,
                        isDiamondSplit: true,
                        splitDirection: direction,
                        originalX: newX,
                        originalY: originalDiamond.y,
                        isVisible: true,
                        lastVisibilityToggle: 0,
                        invisibilityDuration: 0,
                        hasShot: false,
                        // Keep drawing size consistent with the reduced width
                        originalSize: Math.max(8, originalDiamond.originalSize * 0.6),
                        isMainFormation: true // Split diamonds move with formation
                    };
        }

        // Shoot bullet
        function shoot() {
            bullets.push({
                x: player.x + player.width / 2 - 2,
                y: player.y,
                width: 4,
                height: 10,
                speed: 7,
                color: '#ffffff'
            });
        }

        // Invaders shoot (triangles and hit squares)
        function invaderShoot(timeMultiplier) {
                    // If we've already reached the max allowed invader bullets, skip shooting this tick
                    if (invaderBullets.length >= MAX_INVADER_BULLETS) return;

                    invaders.forEach(invader => {
                if (invader.alive && invader.isVisible) {
                    let shouldShoot = false;
                    let shootChance = 0;
                    
                    if (invader.type.canShoot) {
                        // Triangle shooting logic
                        const baseChance = 0.001;
                        shootChance = baseChance * invader.shootSpeed * timeMultiplier;
                        shouldShoot = Math.random() < shootChance;
                    }
                    
                    if (shouldShoot) {
                        // Double-check limit before spawning each bullet (in case multiple invaders try to fire)
                        if (invaderBullets.length >= MAX_INVADER_BULLETS) return;
                        // Triangles should aim at player's current position
                        if (invader.type.shape === 'triangle') {
                            const targetX = player.x + player.width / 2;
                            const targetY = player.y + player.height / 2;
                            const startX = invader.x + invader.width / 2 - 2;
                            const startY = invader.y + invader.height;
                            const speed = 3;
                            const dx = targetX - startX;
                            const dy = targetY - startY;
                            const len = Math.hypot(dx, dy) || 1;
                            invaderBullets.push({
                                x: startX,
                                y: startY,
                                width: 4,
                                height: 10,
                                vx: (dx / len) * speed,
                                vy: (dy / len) * speed,
                                color: '#ff0000'
                            });
                        } else {
                            invaderBullets.push({
                                x: invader.x + invader.width / 2 - 2,
                                y: invader.y + invader.height,
                                width: 4,
                                height: 10,
                                speed: 3,
                                color: '#ff0000'
                            });
                        }
                    }
                }
            });
        }

        // Square shoots immediately when hit
        function squareShoot(invader) {
                    // Don't spawn if we've reached the global cap of invader bullets
                    if (invaderBullets.length >= MAX_INVADER_BULLETS) return;

                    invaderBullets.push({
                        x: invader.x + invader.width / 2 - 2,
                        y: invader.y + invader.height,
                        width: 4,
                        height: 10,
                        vx: 0,
                        vy: 3,
                        color: '#ff0000'
                    });
                    invader.hasShot = true;
        }

        // Create explosion particles
        function createExplosion(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Draw functions
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x + 20, player.y - 5, 10, 8);
        }

        function drawInvader(invader) {
            if (!invader.alive || !invader.isVisible) return;
            
            const centerX = invader.x + invader.width / 2;
            const centerY = invader.y + invader.height / 2;
            
            let size = invader.originalSize;
            if (invader.isDiamondSplit) {
                size = 10;
            } else if (invader.type.shape === 'square' && invader.hits > 0) {
                size = invader.originalSize * 0.6; // Shrink when hit
            }
            
            let color = invader.type.color;
            if (invader.hits > 0 && !invader.isDiamondSplit && invader.type.shape !== 'square') {
                color = darkenColor(invader.type.color, 0.5);
            }
            
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            if (!gamePaused) {
                invader.animFrame += 0.1;
            }
            const pulse = Math.sin(invader.animFrame) * 0.1 + 1;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(pulse, pulse);
            
            if (invader.hits > 0 && !invader.isDiamondSplit && invader.type.shape !== 'square') {
                ctx.scale(0.7, 0.7);
            }
            
            switch (invader.type.shape) {
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(-size, size);
                    ctx.lineTo(size, size);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'diamond':
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'square':
                    ctx.fillRect(-size, -size, size * 2, size * 2);
                    break;
                    
                case 'star':
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        
                        const innerAngle = ((i + 0.5) * Math.PI * 2) / 5 - Math.PI / 2;
                        const innerX = Math.cos(innerAngle) * size * 0.5;
                        const innerY = Math.sin(innerAngle) * size * 0.5;
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            
            ctx.restore();
        }

        function darkenColor(color, factor) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            const newR = Math.floor(r * factor);
            const newG = Math.floor(g * factor);
            const newB = Math.floor(b * factor);
            
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }

        function drawBullet(bullet) {
            ctx.fillStyle = bullet.color;
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        }

        function drawParticle(particle) {
            ctx.fillStyle = particle.color;
            ctx.globalAlpha = particle.life / 30;
            ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
            ctx.globalAlpha = 1;
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function updateSpecialBehaviors(timeMultiplier) {
            if (gamePaused) return;
            
            gameTime += timeMultiplier;
            
            invaders.forEach(invader => {
                if (!invader.alive) return;
                
                if (invader.type.shape === 'circle') {
                    if (Math.random() < 0.002 * timeMultiplier && invader.isVisible) {
                        invader.isVisible = false;
                        invader.invisibilityDuration = 60 + Math.random() * 120;
                    }
                    
                    if (!invader.isVisible) {
                        invader.invisibilityDuration -= timeMultiplier;
                        if (invader.invisibilityDuration <= 0) {
                            invader.isVisible = true;
                        }
                    }
                }
            });
        }

        function update(timeMultiplier = 1) {
            if (!gameRunning || gamePaused) return;
            // If intro banner or level intro is active, don't advance game logic
            if (introActive || levelIntroActive) return; // wait until player presses Space to start level

            updateSpecialBehaviors(timeMultiplier);

            if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed * timeMultiplier;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += player.speed * timeMultiplier;
            }

            bullets = bullets.filter(bullet => {
                bullet.y -= bullet.speed * timeMultiplier;
                return bullet.y > 0;
            });

            invaderBullets = invaderBullets.filter(bullet => {
                if (typeof bullet.vx !== 'undefined' && typeof bullet.vy !== 'undefined') {
                    bullet.x += bullet.vx * timeMultiplier;
                    bullet.y += bullet.vy * timeMultiplier;
                } else {
                    bullet.y += bullet.speed * timeMultiplier;
                }
                return bullet.y < canvas.height && bullet.x >= 0 && bullet.x <= canvas.width;
            });

            // INVADER MOVEMENT - Edge detection
            // We normally ignore split diamonds for edge detection so they don't
            // prematurely flip the formation. However, if there are no remaining
            // "main formation" invaders (e.g. only split diamonds are alive),
            // we must include them; otherwise they can drift off-screen.
            let hitEdge = false;
            const margin = 10; // Safety margin from edges
            const adjustedInvaderSpeed = invaderSpeed * timeMultiplier;

            // First, check only non-split (main formation) invaders
            let mainCount = 0;
            invaders.forEach(invader => {
                if (invader.alive && !invader.isDiamondSplit) {
                    mainCount++;
                    const nextX = invader.x + invaderDirection * adjustedInvaderSpeed;
                    if (nextX <= margin || nextX >= canvas.width - invader.width - margin) {
                        hitEdge = true;
                    }
                }
            });

            // If there are no main formation invaders left, include all alive
            // invaders (including split diamonds) in the edge check so they
            // can't move off-screen when they're the last ones.
            if (!hitEdge && mainCount === 0) {
                invaders.forEach(invader => {
                    if (invader.alive) {
                        const w = invader.width || 20;
                        const nextX = invader.x + invaderDirection * adjustedInvaderSpeed;
                        if (nextX <= margin || nextX >= canvas.width - w - margin) {
                            hitEdge = true;
                        }
                    }
                });
            }

            // Prevent rapid direction changes
            if (hitEdge && gameTime - lastDirectionChange > 30) {
                invaderDirection *= -1;
                lastDirectionChange = gameTime;

                // Move all alive invaders down (reduced descent so the game is slower)
                // Se ha reducido a la mitad: antes 20, ahora 10 para que desplacen hacia abajo m√°s despacio
                invaders.forEach(invader => {
                    if (invader.alive) {
                        invader.y += 10 * timeMultiplier;
                    }
                });
            } else if (!hitEdge) {
                // Move all alive invaders horizontally
                invaders.forEach(invader => {
                    if (invader.alive) {
                        invader.x += invaderDirection * adjustedInvaderSpeed;
                    }
                });
            }

            particles = particles.filter(particle => {
                particle.x += particle.vx * timeMultiplier;
                particle.y += particle.vy * timeMultiplier;
                particle.life -= timeMultiplier;
                return particle.life > 0;
            });

            // Check bullet-invader collisions
            const now = Date.now();
            bullets.forEach((bullet, bulletIndex) => {
                invaders.forEach((invader, invaderIndex) => {
                    // If invaders are in invulnerability window, skip collision checks
                    if (now < invadersInvulnerableUntil) return;
                    if (invader.alive && invader.isVisible && checkCollision(bullet, invader)) {
                        bullets.splice(bulletIndex, 1);
                        
                        createExplosion(invader.x + invader.width / 2, invader.y + invader.height / 2, invader.type.color);
                        
                        if (invader.type.shape === 'triangle') {
                            invader.hits++;
                            if (invader.hits === 1) {
                                invader.shootSpeed = 2;
                                score += Math.floor(invader.type.points / 2);
                            } else if (invader.hits >= 2) {
                                invader.alive = false;
                                score += Math.floor(invader.type.points / 2);
                            }
                        } else if (invader.type.shape === 'diamond') {
                            if (invader.isDiamondSplit) {
                                // Split diamond dies in one hit
                                invader.alive = false;
                                score += Math.floor(invader.type.points / 3);
                            } else {
                                // Original diamond splits into two
                                const leftSplit = createSplitDiamond(invader, -1);
                                const rightSplit = createSplitDiamond(invader, 1);
                                
                                invaders.push(leftSplit, rightSplit);
                                
                                invader.alive = false;
                                score += Math.floor(invader.type.points / 3);
                            }
                        } else if (invader.type.shape === 'square') {
                            invader.hits++;
                            if (invader.hits === 1) {
                                // First hit: shrink and shoot immediately
                                score += Math.floor(invader.type.points / 2);
                                squareShoot(invader); // Shoot immediately
                            } else if (invader.hits >= 2) {
                                // Second hit: destroy
                                invader.alive = false;
                                score += Math.floor(invader.type.points / 2);
                            }
                        } else {
                            invader.hits++;
                            if (invader.hits >= invader.maxHits) {
                                invader.alive = false;
                                score += invader.type.points;
                            } else {
                                score += Math.floor(invader.type.points / invader.maxHits);
                            }
                        }
                    }
                });
            });

            invaderBullets.forEach((bullet, bulletIndex) => {
                if (checkCollision(bullet, player)) {
                    gameRunning = false;
                    gameOverElement.style.display = 'block';
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2, player.color);
                }
            });

            invaders.forEach(invader => {
                if (invader.alive && invader.y + invader.height >= player.y) {
                    gameRunning = false;
                    gameOverElement.style.display = 'block';
                }
            });

            if (invaders.length > 0 && invaders.every(invader => !invader.alive)) {
                level++;
                // update invader speed based on level
                invaderSpeed = baseInvaderSpeed * getInvaderSpeedMultiplier(level);
                // Show the level intro; actual invaders will be created after player starts the level
                showLevelIntro();
                gameTime = 0;
                lastDirectionChange = 0; // Reset direction change timer
            }

            invaderShoot(timeMultiplier);

            scoreElement.textContent = `Score: ${score} | Level: ${level}`;
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < 100; i++) {
                const x = (i * 37) % canvas.width;
                const y = (i * 73) % canvas.height;
                const brightness = Math.sin(Date.now() * 0.001 + i) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.5})`;
                ctx.fillRect(x, y, 1, 1);
            }

            drawPlayer();
            bullets.forEach(drawBullet);
            invaderBullets.forEach(drawBullet);
            invaders.forEach(drawInvader);
            particles.forEach(drawParticle);
        }

        function gameLoop(currentTime = 0) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Cap the delta time to prevent huge jumps
            const cappedDeltaTime = Math.min(deltaTime, targetFrameTime * 2);
            const timeMultiplier = cappedDeltaTime / targetFrameTime;
            
            update(timeMultiplier);
            render();
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            level = 1;
            gameTime = 0;
            lastDirectionChange = 0; // Reset direction change timer
            bullets = [];
            invaderBullets = [];
            particles = [];
            player.x = canvas.width / 2 - 25;
            gameOverElement.style.display = 'none';
            pausedElement.style.display = 'none';
            document.getElementById('victoryBanner').style.display = 'none';
            document.getElementById('levelIntro').style.display = 'none';
            // clear any existing invaders and show intro banner (with fade)
            invaders = [];
            const introEl = document.getElementById('introBanner');
            introEl.style.display = 'block';
            fadeIn(introEl);
            introActive = true;
            invaderDirection = 1;
            baseInvaderSpeed = 0.5;
            invaderSpeed = baseInvaderSpeed * getInvaderSpeedMultiplier(level);
            invadersInvulnerableUntil = 0;
        }

    // Show intro banner on load (with fade)
    const introEl = document.getElementById('introBanner');
    introEl.style.display = 'block';
    fadeIn(introEl);
    introActive = true;
    // start game loop (invaders will be created after intro is dismissed)
    gameLoop();
    </script>
</body>
</html>